<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Mini-Voxel — Cool_Craft Prototype</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; overflow:hidden; font-family:Arial,Helvetica,sans-serif; }
    #info {
      position: absolute; top: 10px; left: 10px; z-index: 2;
      background: rgba(0,0,0,0.4); color: white; padding:8px 10px; border-radius:6px;
      font-size:14px;
    }
    #hint { position: absolute; bottom: 12px; left: 12px; color: white; }
    canvas { display:block; }
    .btn {
      background:#2b6cb0; color:white; border:none; padding:6px 8px; border-radius:4px; cursor:pointer;
      margin-left:8px;
    }
  </style>
</head>
<body>
  <div id="info">
    WASD: bewegen • Maus: schauen • Linksklick: Block entfernen • Rechtsklick: Block platzieren
    <button id="reset" class="btn">Reset</button>
  </div>
  <div id="hint"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/PointerLockControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0,50,0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,10,7);
    scene.add(dir);

    const controls = new PointerLockControls(camera, renderer.domElement);
    document.body.addEventListener('click', () => { controls.lock(); }, {once:true});

    const move = { fwd:false, back:false, left:false, right:false };
    let velocity = new THREE.Vector3();
    let canJump = true;

    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') move.fwd=true;
      if (e.code === 'KeyS') move.back=true;
      if (e.code === 'KeyA') move.left=true;
      if (e.code === 'KeyD') move.right=true;
      if (e.code === 'Space' && canJump) { velocity.y += 6; canJump=false; }
    });
    document.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') move.fwd=false;
      if (e.code === 'KeyS') move.back=false;
      if (e.code === 'KeyA') move.left=false;
      if (e.code === 'KeyD') move.right=false;
    });

    const blockSize = 1;
    const cubeGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
    const materials = {
      grass: new THREE.MeshLambertMaterial({color:0x7fbf3f}),
      dirt: new THREE.MeshLambertMaterial({color:0x8b5a2b}),
      stone: new THREE.MeshLambertMaterial({color:0x999999})
    };

    const blocks = new Map();
    function posKey(x,y,z){ return `${x},${y},${z}`; }
    function addBlock(x,y,z, type='grass'){
      const key = posKey(x,y,z);
      if (blocks.has(key)) return;
      const m = new THREE.Mesh(cubeGeo, materials[type] || materials.dirt);
      m.position.set(x*blockSize, y*blockSize, z*blockSize);
      m.userData.voxel = {x,y,z};
      scene.add(m);
      blocks.set(key, m);
    }
    function removeBlockAt(x,y,z){
      const key = posKey(x,y,z);
      const m = blocks.get(key);
      if (!m) return;
      scene.remove(m);
      blocks.delete(key);
    }

    const size = 16;
    for (let x=-size/2; x<size/2; x++){
      for (let z=-size/2; z<size/2; z++){
        const h = Math.floor(1 + Math.abs(Math.sin(x*0.3) + Math.cos(z*0.3))*2);
        for (let y=0; y<h; y++){
          addBlock(x, y, z, y===h-1 ? 'grass' : 'dirt');
        }
      }
    }

    const raycaster = new THREE.Raycaster();
    function getIntersect(){
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects(Array.from(blocks.values()));
      return intersects.length ? intersects[0] : null;
    }

    window.addEventListener('mousedown', (e) => {
      if (!controls.isLocked) return;
      const hit = getIntersect();
      if (!hit) return;
      const v = hit.object.userData.voxel;
      if (e.button === 0){
        if (v.y === 0) return;
        removeBlockAt(v.x, v.y, v.z);
      } else if (e.button === 2){
        const normal = hit.face.normal;
        const nx = v.x + Math.round(normal.x);
        const ny = v.y + Math.round(normal.y);
        const nz = v.z + Math.round(normal.z);
        addBlock(nx, ny, nz, 'dirt');
      }
    });
    window.addEventListener('contextmenu', (e) => e.preventDefault());

    const hint = document.getElementById('hint');
    hint.innerText = 'Klicke ins Fenster, um Maussteuerung zu aktivieren.';

    document.getElementById('reset').addEventListener('click', () => {
      blocks.forEach(m => scene.remove(m));
      blocks.clear();
      for (let x=-size/2; x<size/2; x++){
        for (let z=-size/2; z<size/2; z++){
          const h = Math.floor(1 + Math.abs(Math.sin(x*0.3) + Math.cos(z*0.3))*2);
          for (let y=0; y<h; y++){
            addBlock(x, y, z, y===h-1 ? 'grass' : 'dirt');
          }
        }
      }
      camera.position.set(0,2,5);
    });

    const groundGeo = new THREE.PlaneGeometry(200,200);
    const groundMat = new THREE.MeshLambertMaterial({color:0x3b7a3b});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.5;
    scene.add(ground);

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const delta = Math.min(0.1, clock.getDelta());

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      velocity.y -= 9.8 * delta;

      const speed = 6.0;
      if (move.fwd) velocity.z -= speed * delta;
      if (move.back) velocity.z += speed * delta;
      if (move.left) velocity.x -= speed * delta;
      if (move.right) velocity.x += speed * delta;

      controls.moveRight(-velocity.x * delta);
      controls.moveForward(-velocity.z * delta);
      camera.position.y += velocity.y * delta;

      if (camera.position.y < 1.6){
        velocity.y = 0;
        camera.position.y = 1.6;
        canJump = true;
      }
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>